import numpy as np
from scipy.spatial import cKDTree
import shapely.geometry as shg
import copy as cp

count = 0
max = 90
parent_id = 1
id = 1
inter_pts = 7
prev_ang = 0
r = np.linspace(.99,.26,inter_pts)
#stack initial point
segments = []
segments_term = [np.array([0.,0])]
dist_min=1

# funtion to generate point for line segment
# rot in radians
def rotate(start_pt,rot,r):
  start_pt = np.array(start_pt) + np.array([0, 1])
  R = np.array([[np.cos(rot*np.pi/180),-np.sin(rot*np.pi/180)],[np.sin(rot*np.pi/180),np.cos(rot*np.pi/180)]])
  return np.dot(R,start_pt)

Axiom: R(5,max,parent_id,id,prev_ang,segments,segments_term,dist_min)

derivation length: 10
production:
R(x,max,parent_id,id,prev_ang,segments,segments_term,dist_min):
  count = 0
  hammerTime = True
  ang = (np.random.random()*(-2*max)+max) + prev_ang
  start_pt = segments_term[parent_id-1]
  if x>60:
    while count <= (inter_pts-1) and hammerTime:
      term_pt = rotate(start_pt, ang*np.pi/180., r[count])
      probe_line = shg.LineString([start_pt, term_pt])
      #get list of segments other than last
      rel_segments = segments[:(parent_id-1)] + segments[parent_id:]
      dist_min = 1
      if rel_segments:
        dist_min = np.min( [probe_line.distance(obj) for obj in rel_segments ] )
      # if we go to far we try withdraw a bit
      if dist_min == 0:
        count = count + 1
        ang = np.random.random()*(-2*max)+max + prev_ang
      else:
        segments.append( cp.copy(probe_line) )
        segments_term.append(term_pt)
        hammerTime = False
        y = np.random.randint(100)
        z = np.random.randint(100)
        produce @SetColor(0) ^(ang) F(r[count],.05) P(z,max,id,id+1,ang,segments,segments_term,dist_min)    #R(y,max,parent_id,id+2,segments,segments_term)
  else:
    while count <= (inter_pts-1) and hammerTime:
      term_pt = rotate(start_pt, ang*np.pi/180., r[count])
      probe_line = shg.LineString([start_pt, term_pt])
      rel_segments = segments[:(parent_id-1)] + segments[parent_id:]
      dist_min = 1
      if rel_segments:
        dist_min = np.min( [probe_line.distance(obj) for obj in rel_segments ] )
      # if we go to far we try withdraw a bit
      if dist_min == 0 :
        count = count + 1
        ang = (np.random.random()*(-2*max)+max) + prev_ang
      else:
        segments.append( cp.copy(probe_line) )
        segments_term.append(term_pt)
        hammerTime = False
        y = np.random.randint(100)
        z = np.random.randint(100)
        produce  @SetColor(0)  ^(ang) F(r[count],.05) P(y,max,id,id+1,ang,segments,segments_term,dist_min) 
        
P(x,max,parent_id,id,prev_ang,segments,segments_term,dist_min):
  count = 0
  hammerTime = True
  ang = (np.random.random()*(-2*max)+max)+prev_ang
  start_pt = segments_term[parent_id-1]
  if x>60:
    while count <= (inter_pts-1) and hammerTime:
      term_pt = rotate(start_pt, ang*np.pi/180., r[count])
      p_line = shg.LineString([start_pt, term_pt])
      rel_segments = segments[:(parent_id-1)] + segments[parent_id:]
      dist_min = 1
      if rel_segments:
        dist_min = np.min( [p_line.distance(obj) for obj in rel_segments ] )
      # if we go to far we try withdraw a bit
      if dist_min == 0 :
        count = count + 1
        ang = (np.random.random()*(-2*max)+max)+prev_ang
      else:
        segments.append( cp.copy(p_line) )
        segments_term.append(term_pt)
        hammerTime = False
        y = np.random.randint(100)
        z = np.random.randint(100)
        produce @SetColor(0) ^(ang) F(r[count],.05) R(z,max,id,id+1,ang,segments,segments_term,dist_min)     #R(y,max,parent_id,id+2,segments,segments_term)
  else:
    while count <= (inter_pts-1) and hammerTime:
      term_pt = rotate(start_pt, ang*np.pi/180., r[count])
      p_line = shg.LineString([start_pt, term_pt])
      rel_segments = segments[:(parent_id-1)] + segments[parent_id:]
      dist_min = 1
      if rel_segments:
        dist_min = np.min( [p_line.distance(obj) for obj in rel_segments ] )
      # if we go to far we try withdraw a bit
      if dist_min ==0 :
        count = count + 1
        ang=(np.random.random()*(-2*max)+max)+prev_ang
      else:
        segments.append( cp.copy(p_line) )
        segments_term.append(term_pt)
        hammerTime = False
        y = np.random.randint(100)
        z = np.random.randint(100)
        produce  @SetColor(0) ^(ang) F(r[count],.05) R(y,max,id,id+1,ang,segments,segments_term) 

interpretation:


endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	context.animation_timestep = 0.001
